/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/00766e0e-637a-4a09-a65b-129c27cf838d

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  CloudDimmedLight brightness;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"



void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  Serial.println("in");

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */


  // analogWrite(A0, 512);


  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();


  PORT->Group[g_APinDescription[6].ulPort].PINCFG[g_APinDescription[6].ulPin].bit.DRVSTR = 1;
  REG_GCLK_GENDIV = GCLK_GENDIV_DIV(8) |          // Divide the 48MHz clock source by divisor 1: 48MHz/1=48MHz
                    GCLK_GENDIV_ID(4);            // Select Generic Clock (GCLK) 4
  while (GCLK->STATUS.bit.SYNCBUSY);              // Wait for synchronization

  REG_GCLK_GENCTRL = GCLK_GENCTRL_IDC |           // Set the duty cycle to 50/50 HIGH/LOW
                     GCLK_GENCTRL_GENEN |         // Enable GCLK4
                     GCLK_GENCTRL_SRC_DFLL48M |   // Set the 48MHz clock source
                     GCLK_GENCTRL_ID(4);          // Select GCLK4
  while (GCLK->STATUS.bit.SYNCBUSY);              // Wait for synchronization

  // Enable the port multiplexer for the TCC0 PWM channel 2 (digital pin D6), SAMD21 pin PA20
  PORT->Group[g_APinDescription[6].ulPort].PINCFG[g_APinDescription[6].ulPin].bit.PMUXEN = 1;

  // Connect the TCC0 timer to the port outputs - port pins are paired odd PMUO and even PMUXE
  // F & E specify the timers: TCC0, TCC1 and TCC2
  PORT->Group[g_APinDescription[6].ulPort].PMUX[g_APinDescription[6].ulPin >> 1].reg |= /*PORT_PMUX_PMUXO_F |*/ PORT_PMUX_PMUXE_F;

  // Feed GCLK4 to TCC0 and TCC1
  REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN |         // Enable GCLK4 to TCC0 and TCC1
                     GCLK_CLKCTRL_GEN_GCLK4 |     // Select GCLK4
                     GCLK_CLKCTRL_ID_TCC0_TCC1;   // Feed GCLK4 to TCC0 and TCC1
  while (GCLK->STATUS.bit.SYNCBUSY);              // Wait for synchronization

  // Normal (single slope) PWM operation: timer countinuouslys count up to PER register value and then is reset to 0
  REG_TCC0_WAVE |= TCC_WAVE_WAVEGEN_NPWM;         // Setup single slope PWM on TCC0
  while (TCC0->SYNCBUSY.bit.WAVE);                // Wait for synchronization

  // Each timer counts up to a maximum or TOP value set by the PER (period) register,
  // this determines the frequency of the PWM operation:
  // 1919 = 25kHz
  REG_TCC0_PER = 750;      // Set the frequency of the PWM on TCC0 to 25kHz
  REG_TCC2_CC0
  while(TCC0->SYNCBUSY.bit.PER);

  // The CCBx register value determines the duty cycle
  // REG_TCC0_CCB2 = 959;       // TCC0 CCB2 - 50% duty cycle on D6
  TCC0->CCB[2].reg = 499;
  while(TCC0->SYNCBUSY.bit.CCB2);

  // Divide the 48MHz signal by 1 giving 48MHz (20.8ns) TCC0 timer tick and enable the outputs
  REG_TCC0_CTRLA |= TCC_CTRLA_PRESCALER_DIV1 |    // Divide GCLK4 by 1
                    TCC_CTRLA_ENABLE;             // Enable the TCC0 output
  while (TCC0->SYNCBUSY.bit.ENABLE);              // Wait for synchronization
}

void loop() {
  ArduinoCloud.update();
  // Your code here
  // TCC1->CC[0].reg = brightness.getBrightness() * 999;
  // while (TCC1->SYNCBUSY.bit.CC0);
  // TCC0->CCB[2].reg  = 80;                        // TCC1 CCB1 - 25% duty cycle on D7
  // while (TCC0->SYNCBUSY.bit.CCB2);                // Wait for synchronization
  // delay(10000);                                    // Wait for 1 second
  // TCC0->CCB[2].reg = 600;                        // TCC1 CCB1 - 75% duty cycle on D7
  // while (TCC0->SYNCBUSY.bit.CCB2);                // Wait for synchronization
  // delay(10000);
//   analogWrite(CONTROL_PIN, 127);
//   delay(5000);
  analogWrite(CONTROL_PIN, 200);
//   delay(5000);
//   analogWrite(CONTROL_PIN, 40);
// delay(5000);


// TCC1->CC0[0].reg = 1500;                        // TCC1 CCB1 - 25% duty cycle on D7
//   while (TCC1->SYNCBUSY.bit.CC0);                // Wait for synchronization
//   delay(5000);                                    // Wait for 1 second
//   TCC1->CC0[0].reg = 4500;                        // TCC1 CCB1 - 75% duty cycle on D7
//   while (TCC1->SYNCBUSY.bit.CC0);                // Wait for synchronization
//   delay(5000);                                    // Wait for 1 second
}



/*
  Since Brightness is READ_WRITE variable, onBrightnessChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onBrightnessChange()  {
  // Add your code here to act upon Brightness change
  if (brightness.getSwitch()) {
    TCC0->CCB[2].reg = (int) (brightness.getBrightness() * 7.499);
  // TCC1->CCB[0].reg = (int)(brightness.getBrightness() * 5999);
  // while (TCC1->SYNCBUSY.bit.CCB0);
  //   // analogWrite(CONTROL_PIN, brightness.getBrightness() * 2.55);
  } else {
  //   TCC1->CCB[0].reg = 300;
  //   while (TCC1->SYNCBUSY.bit.CCB0);
    TCC0->CCB[2].reg = 0;
  }
}
